---
layout: post
title: 各种各样的LCS
date: 2019-04-16
description: 明明只是一个最长公共子序列的题还玩出这么多花样= =
tag: 算法
---

### 题目说明
#### 第一种情况
> 给定两个数字m、n，先后输入m个数和n个数，作为两个序列
>
> 例:
>
> > a[] = {2, 7, 3, 4, 4}
> >
> > b[] = {5, 3, 5, 4, 4, 7}
> >
> > 最大子序列是{3, 4, 4}
> >
> > 最大子串是{4, 4}
>
> 可见子序列的特点是顺序不变， 但可以隔着取；而字串是只能取相邻的数

#### 第二种情况
> 给定两个字符串，作为两个序列
>
> > 例:
> >
> > a = "abcdefg"
> >
> > b = "acdeffdg"
> >
> > 最大子序列是 "acdefg"
> >
> > 最大字串是 "cdef"
>
> 与上方同理

### 解法
#### （一）：打表回溯
思路就是将两个序列当作行标和列表存储起来，最后通过存储的数字来找到最大公共子序列

例:
> m = 5
>
> n = 6
>
> a[] = {2, 7, 3, 4, 4}
>
> b[] = {5, 3, 5, 4, 4, 7}
**那么在存储时情况如下【打表**

规则是：
1. 第一行第一列的两个数如果相同，填入“1”；

  如果不同，填入“0”。

2. 其他位置的两个数如果相同，取 **左上角** 的数字 **加一** 填入；

  如果不同，填入 **上边** 或 **左边** 的两个数中最大的那个数。

![存储演示](/images/20190416/LCSS.gif)

可以看到最小的数字一定在最左上角，最大的数字一定在最右下角，之后我们会利用这一点来回溯寻找最大子序列

**表格做好以后寻找我们需要的最长子序列（回溯**

回溯方法是：

从最左下角的数字查找，如果对应的两个数相同，将这个数储存起来并往左上角移动；

如果对应的两个数不同，从上面或左边找一个最大的数去移动。

![回溯演示](/images/20190416/LCSF.gif)

这样我们就把所有相同的数储存起来了

存储的结果就是我们要找的**最大公共子序列**
